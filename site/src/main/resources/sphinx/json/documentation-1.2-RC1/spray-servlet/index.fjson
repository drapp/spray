{"body": "<div class=\"section\" id=\"spray-servlet\">\n<span id=\"id1\"></span><h1>spray-servlet</h1>\n<p><em>spray-servlet</em> is an adapter layer providing (a subset of) the <em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-server/#http-server\"><em>HTTP Server</em></a> interface on top of the\nServlet API. As one main application it enables the use of <a class=\"reference internal\" href=\"../spray-routing/#spray-routing\"><em>spray-routing</em></a> in a servlet container.</p>\n<div class=\"section\" id=\"dependencies\">\n<h2>Dependencies</h2>\n<p>Apart from the Scala library (see <a class=\"reference internal\" href=\"../../project-info/current-versions/#current-versions\"><em>Current Versions</em></a> chapter) <em>spray-can</em> depends on</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"../spray-http/#spray-http\"><em>spray-http</em></a></li>\n<li><a class=\"reference internal\" href=\"../spray-util/#spray-util\"><em>spray-util</em></a></li>\n<li><a class=\"reference internal\" href=\"../spray-io/#spray-io\"><em>spray-io</em></a> (only required until the upgrade to Akka 2.2, will go away afterwards)</li>\n<li>akka-actor 2.2.x (with &#8216;provided&#8217; scope, i.e. you need to pull it in yourself)</li>\n<li>the Servlet-3.0 API (with &#8216;provided&#8217; scope, usually automatically available from your servlet container)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"installation\">\n<h2>Installation</h2>\n<p>The <a class=\"reference internal\" href=\"../../project-info/maven-repository/#maven-repo\"><em>Maven Repository</em></a> chapter contains all the info about how to pull <em>spray-servlet</em> into your classpath.\nYou might also want to check out:</p>\n<ul class=\"simple\">\n<li>The <a class=\"reference external\" href=\"https://github.com/JamesEarlDouglas/xsbt-web-plugin\">xsbt-web-plugin</a> for simplifying the development process</li>\n<li>The <a class=\"reference internal\" href=\"../../introduction/getting-started/#getting-started\"><em>Getting Started</em></a> chapter for info on the <em>spray</em> project template for <em>spray-servlet</em></li>\n</ul>\n</div>\n<div class=\"section\" id=\"configuration\">\n<h2>Configuration</h2>\n<p>Just like Akka <em>spray-servlet</em> relies on the <a class=\"reference external\" href=\"https://github.com/typesafehub/config\">typesafe config</a> library for configuration. As such its JAR contains a\n<tt class=\"docutils literal\"><span class=\"pre\">reference.conf</span></tt> file holding the default values of all configuration settings. In your application you typically\nprovide an <tt class=\"docutils literal\"><span class=\"pre\">application.conf</span></tt>, in which you override Akka and/or <em>spray</em> settings according to your needs.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Since <em>spray</em> uses the same configuration technique as Akka you might want to check out the\n<a class=\"reference external\" href=\"http://doc.akka.io/docs/akka/2.0.4/general/configuration.html\">Akka Documentation on Configuration</a>.</p>\n</div>\n<p>This is the <tt class=\"docutils literal\"><span class=\"pre\">reference.conf</span></tt> of the <em>spray-servlet</em> module:</p>\n<div class=\"highlight-bash\"><div class=\"highlight\"><pre><span class=\"c\">#######################################</span>\n<span class=\"c\"># spray-servlet Reference Config File #</span>\n<span class=\"c\">#######################################</span>\n\n<span class=\"c\"># This is the reference config file that contains all the default settings.</span>\n<span class=\"c\"># Make your edits/overrides in your application.conf.</span>\n\nspray.servlet <span class=\"o\">{</span>\n\n    <span class=\"c\"># The FQN (Fully Qualified Name) of the class to load when the</span>\n    <span class=\"c\"># servlet context is initialized (e.g. &quot;com.example.ApiBoot&quot;).</span>\n    <span class=\"c\"># The class must have a constructor with a single</span>\n    <span class=\"c\"># `javax.servlet.ServletContext` parameter and implement</span>\n    <span class=\"c\"># the `spray.servlet.WebBoot` trait.</span>\n    boot-class <span class=\"o\">=</span> <span class=\"s2\">&quot;&quot;</span>\n\n    <span class=\"c\"># If a request hasn&#39;t been responded to after the time period set here</span>\n    <span class=\"c\"># a `spray.http.Timedout` message will be sent to the timeout handler.</span>\n    <span class=\"c\"># Set to `infinite` to completely disable request timeouts.</span>\n    request-timeout <span class=\"o\">=</span> 30 s\n\n    <span class=\"c\"># After a `Timedout` message has been sent to the timeout handler and the</span>\n    <span class=\"c\"># request still hasn&#39;t been completed after the time period set here</span>\n    <span class=\"c\"># the server will complete the request itself with an error response.</span>\n    <span class=\"c\"># Set to `infinite` to disable timeout timeouts.</span>\n    timeout-timeout <span class=\"o\">=</span> 500 ms\n\n    <span class=\"c\"># The path of the actor to send `spray.http.Timedout` messages to.</span>\n    <span class=\"c\"># If empty all `Timedout` messages will go to the &quot;regular&quot; request handling actor.</span>\n    timeout-handler <span class=\"o\">=</span> <span class=\"s2\">&quot;&quot;</span>\n\n    <span class=\"c\"># A path prefix that is automatically &quot;consumed&quot; before the request is</span>\n    <span class=\"c\"># being dispatched to the HTTP service route.</span>\n    <span class=\"c\"># Can be used to match servlet context paths configured for the application.</span>\n    <span class=\"c\"># Make sure to include a leading slash with your prefix, e.g. &quot;/foobar&quot;.</span>\n    root-path <span class=\"o\">=</span> <span class=\"s2\">&quot;&quot;</span>\n\n    <span class=\"c\"># Enables/disables the addition of a `Remote-Address` header</span>\n    <span class=\"c\"># holding the clients (remote) IP address.</span>\n    remote-address-header <span class=\"o\">=</span> off\n\n    <span class=\"c\"># Enables/disables the returning of more detailed error messages to</span>\n    <span class=\"c\"># the client in the error response.</span>\n    <span class=\"c\"># Should be disabled for browser-facing APIs due to the risk of XSS attacks</span>\n    <span class=\"c\"># and (probably) enabled for internal or non-browser APIs.</span>\n    <span class=\"c\"># Note that spray will always produce log messages containing the full error details.</span>\n    verbose-error-messages <span class=\"o\">=</span> off\n\n    <span class=\"c\"># The maximum size of the request entity that is still accepted by the server.</span>\n    <span class=\"c\"># Requests with a greater entity length are rejected with an error response.</span>\n    <span class=\"c\"># Must be greater than zero.</span>\n    max-content-length <span class=\"o\">=</span> 5 m\n\n    <span class=\"c\"># Enables/disables the inclusion of `spray.servlet.ServletRequestInfoHeader` in the</span>\n    <span class=\"c\"># headers of the HTTP request sent to the service actor.</span>\n    servlet-request-access <span class=\"o\">=</span> off\n\n    <span class=\"c\"># Enables/disables the logging of warning messages in case an incoming</span>\n    <span class=\"c\"># message (request or response) contains an HTTP header which cannot be</span>\n    <span class=\"c\"># parsed into its high-level model class due to incompatible syntax.</span>\n    <span class=\"c\"># Note that, independently of this settings, spray will accept messages</span>\n    <span class=\"c\"># with such headers as long as the message as a whole would still be legal</span>\n    <span class=\"c\"># under the HTTP specification even without this header.</span>\n    <span class=\"c\"># If a header cannot be parsed into a high-level model instance it will be</span>\n    <span class=\"c\"># provided as a `RawHeader`.</span>\n    illegal-header-warnings <span class=\"o\">=</span> on\n\n    <span class=\"c\"># Sets the strictness mode for parsing request target URIs.</span>\n    <span class=\"c\"># The following values are defined:</span>\n    <span class=\"c\">#</span>\n    <span class=\"c\"># `strict`: RFC3986-compliant URIs are required,</span>\n    <span class=\"c\">#     a 400 response is triggered on violations</span>\n    <span class=\"c\">#</span>\n    <span class=\"c\"># `relaxed`: all visible 7-Bit ASCII chars are allowed</span>\n    <span class=\"c\">#</span>\n    <span class=\"c\"># `relaxed-with-raw-query`: like `relaxed` but additionally</span>\n    <span class=\"c\">#     the URI query is not parsed, but delivered as one raw string</span>\n    <span class=\"c\">#     as the `key` value of a single Query structure element.</span>\n    <span class=\"c\">#</span>\n    uri-parsing-mode <span class=\"o\">=</span> relaxed\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"basic-architecture\">\n<h2>Basic Architecture</h2>\n<p>The central element of <em>spray-servlet</em> is the <tt class=\"docutils literal\"><span class=\"pre\">Servlet30ConnectorServlet</span></tt>. Its job is to accept incoming HTTP\nrequests, suspend them (using Servlet 3.0 <tt class=\"docutils literal\"><span class=\"pre\">startAsync</span></tt>), create immutable <a class=\"reference internal\" href=\"../spray-http/#spray-http\"><em>spray-http</em></a> <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> instances\nfor them and dispatch these to a service actor provided by the application.</p>\n<p>The messaging API as seen from the application is modeled as closely as possible like its counterpart, the\n<em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-server/#http-server\"><em>HTTP Server</em></a>.</p>\n<p>In the most basic case, the service actor completes a request by simply replying\nwith an <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance to the request sender:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">receive</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">case</span> <span class=\"nc\">HttpRequest</span><span class=\"o\">(...)</span> <span class=\"k\">=&gt;</span> <span class=\"n\">sender</span> <span class=\"o\">!</span> <span class=\"nc\">HttpResponse</span><span class=\"o\">(...)</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"starting-and-stopping\">\n<h2>Starting and Stopping</h2>\n<p>A <em>spray-servlet</em> application is started by the servlet container. The application JAR should contain a <tt class=\"docutils literal\"><span class=\"pre\">web.xml</span></tt>\nsimilar to <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/master/examples/spray-servlet/simple-spray-servlet-server/src/main/webapp/WEB-INF/web.xml\">this one</a> from the <a class=\"reference internal\" href=\"#simple-spray-servlet-server\">simple-spray-servlet-server</a> example.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">web.xml</span></tt> registers a <tt class=\"docutils literal\"><span class=\"pre\">ServletContextListener</span></tt> (<tt class=\"docutils literal\"><span class=\"pre\">spray.servlet.Initializer</span></tt>), which initializes the\napplication when the servlet is started. The <tt class=\"docutils literal\"><span class=\"pre\">Initializer</span></tt> loads the configured <tt class=\"docutils literal\"><span class=\"pre\">boot-class</span></tt> and instantiates it\nusing the default constructor, which must be available. The boot class must implement the <tt class=\"docutils literal\"><span class=\"pre\">WebBoot</span></tt> trait, which is\ndefined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"cm\">/**</span>\n<span class=\"cm\"> * Trait that must be implemented by the Boot class.</span>\n<span class=\"cm\"> */</span>\n<span class=\"k\">trait</span> <span class=\"nc\">WebBoot</span> <span class=\"o\">{</span>\n\n  <span class=\"cm\">/**</span>\n<span class=\"cm\">   * The ActorSystem the application would like to use.</span>\n<span class=\"cm\">   */</span>\n  <span class=\"k\">def</span> <span class=\"n\">system</span><span class=\"k\">:</span> <span class=\"kt\">ActorSystem</span>\n\n  <span class=\"cm\">/**</span>\n<span class=\"cm\">   * The service actor to dispatch incoming HttpRequests to.</span>\n<span class=\"cm\">   */</span>\n  <span class=\"k\">def</span> <span class=\"n\">serviceActor</span><span class=\"k\">:</span> <span class=\"kt\">ActorRef</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>A very basic boot class implementation is <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/master/examples/spray-servlet/simple-spray-servlet-server/src/main/scala/spray/examples/Boot.scala\">this one</a> from the <a class=\"reference internal\" href=\"#simple-spray-servlet-server\">simple-spray-servlet-server</a> example.</p>\n<p>The boot class is responsible for creating the Akka <tt class=\"docutils literal\"><span class=\"pre\">ActorSystem</span></tt> for the application as well as the service actor.\nWhen the application is shut down by the servlet container the <tt class=\"docutils literal\"><span class=\"pre\">Initializer</span></tt> shuts down the <tt class=\"docutils literal\"><span class=\"pre\">ActorSystem</span></tt>, which\ncleanly terminates all application actors including the service actor.</p>\n</div>\n<div class=\"section\" id=\"message-protocol\">\n<h2>Message Protocol</h2>\n<p>Just like in its counterpart, the <em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-server/#http-server\"><em>HTTP Server</em></a>, all communication between the connector servlet and\nthe application happens through actor messages.</p>\n<div class=\"section\" id=\"request-response-cycle\">\n<h3>Request-Response Cycle</h3>\n<p>As soon as a new request has been successfully read from the servlet API it is dispatched to the service actor\ncreated by the boot class. The service actor processes the request according\nto the application logic and responds by sending an <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance to the <tt class=\"docutils literal\"><span class=\"pre\">sender</span></tt> of the request.</p>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> used as the sender of an <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> received by the service actor is unique to the\nrequest, i.e. each request will appear to be sent from different senders. <em>spray-servlet</em> uses these sender\n<tt class=\"docutils literal\"><span class=\"pre\">ActorRefs</span></tt> to coalesce the response with the request, so you cannot sent several responses to the same sender.\nHowever, the different response parts of a chunked response need to be sent to the same sender.</p>\n<div class=\"admonition caution\">\n<p class=\"first admonition-title\">Caution</p>\n<p class=\"last\">Since the <tt class=\"docutils literal\"><span class=\"pre\">ActorRef</span></tt> used as the sender of a request is an <a class=\"reference external\" href=\"/documentation/1.1-M7/spray-util/#unregisteredactorref\">UnregisteredActorRef</a> it is not\nreachable remotely. This means that the service actor needs to live in the same JVM as the connector servlet.</p>\n</div>\n</div>\n<div class=\"section\" id=\"chunked-responses\">\n<h3>Chunked Responses</h3>\n<p>Alternatively to a single <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instance the handler can choose to respond to the request sender with the\nfollowing sequence of individual messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The connector servlet writes the individual response parts into the servlet response <tt class=\"docutils literal\"><span class=\"pre\">OutputStream</span></tt> and flushes it.\nWhether these parts are really rendered &#8220;to the wire&#8221; as chunked message parts depends on the servlet container\nimplementation. The Servlet API has not dedicated support for chunked responses.</p>\n</div>\n<div class=\"section\" id=\"request-timeouts\">\n<h3>Request Timeouts</h3>\n<p>If the service actor does not complete a request within the configured <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt> period a\n<tt class=\"docutils literal\"><span class=\"pre\">spray.http.Timedout</span></tt> message is sent to the timeout handler, which can be the service actor itself or\nanother actor (depending on the <tt class=\"docutils literal\"><span class=\"pre\">timeout-handler</span></tt> config setting). The timeout handler then has the chance to\ncomplete the request within the time period configured as <tt class=\"docutils literal\"><span class=\"pre\">timeout-timeout</span></tt>. Only if the timeout handler also misses\nits deadline for completing the request will the connector servlet complete the request itself with a &#8220;hard-coded&#8221;\nerror response (which you can change by overriding the <tt class=\"docutils literal\"><span class=\"pre\">timeoutResponse</span></tt> method of the <tt class=\"docutils literal\"><span class=\"pre\">Servlet30ConnectorServlet</span></tt>).</p>\n</div>\n<div class=\"section\" id=\"send-confirmations\">\n<h3>Send Confirmations</h3>\n<p>If required the connector servlet can reply with a &#8220;send confirmation&#8221; message to every response (part) coming in from\nthe application. You request a send confirmation by modifying a response part with the <tt class=\"docutils literal\"><span class=\"pre\">withAck</span></tt> method\n(see the <a class=\"reference internal\" href=\"../spray-can/common-behavior/#acked-sends\"><em>ACKed Sends</em></a> section of the <em>spray-can</em> documentation for example code).\nConfirmation messages are especially helpful for triggering the sending of the next response part in a response\nstreaming scenario, since with such a design the application will never produce more data than the servlet container can\nhandle.</p>\n<p>Send confirmations are always dispatched to the actor, which sent the respective response (part).</p>\n</div>\n<div class=\"section\" id=\"closed-notifications\">\n<h3>Closed Notifications</h3>\n<p>The Servlet API completely hides the actual management of the HTTP connections from the application. Therefore the\nconnector servlet has no real way of finding out whether a connection was closed or not. However, if the connection\nwas closed unexpectedly for whatever reason a subsequent attempt to write to it usually fails with an <tt class=\"docutils literal\"><span class=\"pre\">IOException</span></tt>.\nIn order to adhere to same message protocol as the <em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-server/#http-server\"><em>HTTP Server</em></a> the connector servlet therefore\ndispatches any exception, which the servlet container throws when a response (part) is written, back to the application\nwrapped in an <tt class=\"docutils literal\"><span class=\"pre\">Tcp.ErrorClosed</span></tt> message.</p>\n<p>In addition the connector servlet also dispatches <tt class=\"docutils literal\"><span class=\"pre\">Tcp.Closed</span></tt> notification messages after the final part of a\nresponse has been successfully written to the servlet container. This allows the application to use the same execution\nmodel for <em>spray-servlet</em> as it would for the <em>spray-can</em> <a class=\"reference internal\" href=\"../spray-can/http-server/#http-server\"><em>HTTP Server</em></a>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"http-headers\">\n<h2>HTTP Headers</h2>\n<p>The connector servlet always passes all received headers on to the application. Additionally the values of the\n<tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> headers are interpreted by the servlet itself. All other headers are of no\ninterest to it.</p>\n<p>Also, if your <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> instances include a <tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header they will be ignored\nand <em>not</em> written through to the servlet container (as the connector servlet sets these response headers itself).</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header has special status in <em>spray</em> since its value is part of the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt> model\nclass. Even though the header also remains in the <tt class=\"docutils literal\"><span class=\"pre\">headers</span></tt> list of the <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> <em>spray&#8217;s</em> higher layers\n(like <em>spray-routing</em>) only work with the Content-Type value contained in the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"accessing-httpservletrequest\">\n<h2>Accessing HttpServletRequest</h2>\n<p>If your application needs access to the <tt class=\"docutils literal\"><span class=\"pre\">javax.servlet.http.HttpServletRequest</span></tt>, the <tt class=\"docutils literal\"><span class=\"pre\">spray.servlet.servlet-request-access</span></tt>\nsetting can be set to <tt class=\"docutils literal\"><span class=\"pre\">on</span></tt>. This results in the connector servlet adding an additional request header of type\n<tt class=\"docutils literal\"><span class=\"pre\">spray.servlet.ServletRequestInfoHeader</span></tt>. This allows the service actor (or directives) to access\nmembers of <tt class=\"docutils literal\"><span class=\"pre\">HttpServletRequest</span></tt> that are not in <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt>. This is necessary when working with container\nmanaged security and access to the authenticated principal is required (via <tt class=\"docutils literal\"><span class=\"pre\">getUserPrincipal</span></tt>) or when accessing\nan authenticated client SSL certificate (via <tt class=\"docutils literal\"><span class=\"pre\">getAttribute(&quot;javax.servlet.request.X509Certificate&quot;)</span></tt>).</p>\n</div>\n<div class=\"section\" id=\"differences-to-spray-can\">\n<h2>Differences to spray-can</h2>\n<dl class=\"docutils\">\n<dt>Chunked Requests</dt>\n<dd>Since the Servlet API does not expose the individual request parts of chunked requests to a servlet there is no way\n<em>spray-servlet</em> can pass them through to the application. The way chunked requests are handled is completely up to\nthe servlet container.</dd>\n<dt>Chunked Responses</dt>\n<dd><em>spray-can</em> renders <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt> messages directly to\n&#8220;the wire&#8221;. Since the Servlet API operates on a somewhat higher level of abstraction <em>spray-servlet</em> can only write\nthese messages to the servlet container one by one, with <tt class=\"docutils literal\"><span class=\"pre\">flush</span></tt> calls in between. The way the servlet container\ninterprets these calls is up to its implementation.</dd>\n<dt><em>Closed</em> Messages</dt>\n<dd>The Servlet API completely hides the actual management of the HTTP connections from the application. Therefore the\nconnector servlet has no way of finding out whether a connection was closed or not. In order to provide a similar\nmessage protocol as <em>spray-can</em> the connector servlet therefore simply assumes that all connections are closed after\nthe final part of a response has been written, no matter whether the servlet container actually uses persistent\nconnections or not.</dd>\n<dt>Timeout Semantics</dt>\n<dd>When working with chunked responses the semantics of the <tt class=\"docutils literal\"><span class=\"pre\">request-timeout</span></tt> config setting are different.\nIn <em>spray-can</em> it designates the maximum time, in which a response must have been <em>started</em> (i.e. the first chunk\nreceived), while in <em>spray-servlet</em> it defines the time, in which the response must have been <em>completed</em> (i.e. the\nlast chunk received).</dd>\n<dt>HTTP Pipelining &amp; SSL Support</dt>\n<dd>Whether and how HTTP pipelining and SSL/TLS encryption are supported depends on the servlet container implementation.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"packaging-a-war-file\">\n<h2>Packaging a WAR file</h2>\n<p>If you use the <a class=\"reference external\" href=\"https://github.com/JamesEarlDouglas/xsbt-web-plugin\">xsbt-web-plugin</a> you can very easily package your project into a WAR file with the <tt class=\"docutils literal\"><span class=\"pre\">package</span></tt> command\nprovided by the plugin.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h2>Example</h2>\n<p>The <a class=\"reference external\" href=\"https://github.com/spray/spray/tree/release/1.2/examples/spray-servlet\">/examples/spray-servlet/</a> directory of the <em>spray</em> repository\ncontains a number of example projects for <em>spray-servlet</em>.</p>\n<div class=\"section\" id=\"simple-spray-servlet-server\">\n<h3>simple-spray-servlet-server</h3>\n<p>This example implements a very simple web-site built on top of <em>spray-servlet</em>.\nIt shows off various features like streaming and timeout handling.</p>\n<p>Follow these steps to run it on your machine:</p>\n<ol class=\"arabic\">\n<li><p class=\"first\">Clone the <em>spray</em> repository:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">git</span> <span class=\"n\">clone</span> <span class=\"n\">git</span><span class=\"o\">://</span><span class=\"n\">github</span><span class=\"o\">.</span><span class=\"n\">com</span><span class=\"o\">/</span><span class=\"n\">spray</span><span class=\"o\">/</span><span class=\"n\">spray</span><span class=\"o\">.</span><span class=\"n\">git</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"first\">Change into the base directory:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">cd</span> <span class=\"n\">spray</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"first\">Run SBT:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">sbt</span> <span class=\"s\">&quot;project simple-spray-servlet-server&quot;</span> <span class=\"n\">container</span><span class=\"k\">:</span><span class=\"kt\">start</span> <span class=\"kt\">shell</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"first\">Browse to <a class=\"reference external\" href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a></p>\n</li>\n<li><p class=\"first\">Alternatively you can access the service with <tt class=\"docutils literal\"><span class=\"pre\">curl</span></tt>:</p>\n<div class=\"highlight-scala\"><pre>curl -v 127.0.0.1:8080/ping</pre>\n</div>\n</li>\n<li><p class=\"first\">Stop the service with:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"n\">container</span><span class=\"k\">:</span><span class=\"kt\">stop</span>\n</pre></div>\n</div>\n</li>\n</ol>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "spray-servlet", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-servlet/index", "next": {"link": "../spray-testkit/", "title": "spray-testkit"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-testkit/index", "spray-testkit", "N", "next"], ["documentation/spray-routing/examples", "Complete Examples", "P", "previous"]], "meta": {}, "parents": [{"link": "../", "title": "Documentation"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">spray-servlet</a><ul>\n<li><a class=\"reference internal\" href=\"#dependencies\">Dependencies</a></li>\n<li><a class=\"reference internal\" href=\"#installation\">Installation</a></li>\n<li><a class=\"reference internal\" href=\"#configuration\">Configuration</a></li>\n<li><a class=\"reference internal\" href=\"#basic-architecture\">Basic Architecture</a></li>\n<li><a class=\"reference internal\" href=\"#starting-and-stopping\">Starting and Stopping</a></li>\n<li><a class=\"reference internal\" href=\"#message-protocol\">Message Protocol</a><ul>\n<li><a class=\"reference internal\" href=\"#request-response-cycle\">Request-Response Cycle</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-responses\">Chunked Responses</a></li>\n<li><a class=\"reference internal\" href=\"#request-timeouts\">Request Timeouts</a></li>\n<li><a class=\"reference internal\" href=\"#send-confirmations\">Send Confirmations</a></li>\n<li><a class=\"reference internal\" href=\"#closed-notifications\">Closed Notifications</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#http-headers\">HTTP Headers</a></li>\n<li><a class=\"reference internal\" href=\"#accessing-httpservletrequest\">Accessing HttpServletRequest</a></li>\n<li><a class=\"reference internal\" href=\"#differences-to-spray-can\">Differences to spray-can</a></li>\n<li><a class=\"reference internal\" href=\"#packaging-a-war-file\">Packaging a WAR file</a></li>\n<li><a class=\"reference internal\" href=\"#example\">Example</a><ul>\n<li><a class=\"reference internal\" href=\"#simple-spray-servlet-server\">simple-spray-servlet-server</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../spray-routing/examples/", "title": "Complete Examples"}, "metatags": ""}