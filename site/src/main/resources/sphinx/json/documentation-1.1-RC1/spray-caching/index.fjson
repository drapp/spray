{"body": "<div class=\"section\" id=\"spray-caching\">\n<span id=\"id1\"></span><h1>spray-caching</h1>\n<p><em>spray-caching</em> provides a lightweight and fast in-memory caching functionality based on Akka Futures and\n<a class=\"reference external\" href=\"http://code.google.com/p/concurrentlinkedhashmap/\">concurrentlinkedhashmap</a>. The primary use-case is the &#8220;wrapping&#8221; of an expensive operation with a caching layer that,\nbased on a certain key of type <tt class=\"docutils literal\"><span class=\"pre\">K</span></tt>, runs the wrapped operation only once and returns the the cached value for all\nfuture accesses for the same key (as long as the respective entry has not expired).</p>\n<p>The central idea of a <em>spray-caching</em> cache is to not store the actual values of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> themselves in the cache\nbut rather corresponding Akka Futures, i.e. instances of type <tt class=\"docutils literal\"><span class=\"pre\">Future[T]</span></tt>. This approach has the advantage of nicely\ntaking care of the thundering herds problem where many requests to a particular cache key (e.g. a resource URI) arrive\nbefore the first one could be completed. Normally (without special guarding techniques, like so-called &#8220;cowboy&#8221; entries)\nthis can cause many requests to compete for system resources while trying to compute the same result thereby greatly\nreducing overall system performance. When you use a <em>spray-caching</em> cache the very first request that arrives for a\ncertain cache key causes a future to be put into the cache which all later requests then &#8220;hook into&#8221;. As soon as the\nfirst request completes all other ones complete as well. This minimizes processing time and server load for all requests.</p>\n<div class=\"section\" id=\"dependencies\">\n<h2>Dependencies</h2>\n<p>Apart from the Scala library (see <a class=\"reference internal\" href=\"../../project-info/current-versions/#current-versions\"><em>Current Versions</em></a> chapter) <em>spray-caching</em> depends on</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"../spray-util/#spray-util\"><em>spray-util</em></a></li>\n<li><a class=\"reference external\" href=\"http://code.google.com/p/concurrentlinkedhashmap/\">concurrentlinkedhashmap</a></li>\n<li>akka-actor 2.1.x (with &#8216;provided&#8217; scope, i.e. you need to pull it in yourself)</li>\n</ul>\n</div>\n<div class=\"section\" id=\"installation\">\n<h2>Installation</h2>\n<p>The <a class=\"reference internal\" href=\"../../project-info/maven-repository/#maven-repo\"><em>Maven Repository</em></a> chapter contains all the info about how to pull <em>spray-caching</em> into your classpath.</p>\n<p>Afterwards just <tt class=\"docutils literal\"><span class=\"pre\">import</span> <span class=\"pre\">spray.caching._</span></tt> to bring all relevant identifiers into scope.</p>\n</div>\n<div class=\"section\" id=\"the-cache-interface\">\n<h2>The <cite>Cache</cite> Interface</h2>\n<p>All <em>spray-caching</em> cache implementations implement the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/master/spray-caching/src/main/scala/spray/caching/Cache.scala\">Cache</a> trait, which allow you to interact with the cache\nin through six methods:</p>\n<ul class=\"wide simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">def</span> <span class=\"pre\">apply(key:</span> <span class=\"pre\">Any)(expr:</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">V):</span> <span class=\"pre\">Future[V]</span></tt> wraps an &#8220;expensive&#8221; expression with caching support.</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">def</span> <span class=\"pre\">apply(key:</span> <span class=\"pre\">Any)(future:</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">Future[V]):</span> <span class=\"pre\">Future[V]</span></tt> is similar, but allows the expression to produce\nthe future itself.</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">def</span> <span class=\"pre\">apply(key:</span> <span class=\"pre\">Any)(func:</span> <span class=\"pre\">Promise[V]</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">Unit):</span> <span class=\"pre\">Future[V]</span></tt> provides a &#8220;push-style&#8221; alternative.</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">def</span> <span class=\"pre\">get(key:</span> <span class=\"pre\">Any):</span> <span class=\"pre\">Option[Future[V]]</span></tt> retrieves the future instance that is currently in the cache for\nthe given key. Returns <tt class=\"docutils literal\"><span class=\"pre\">None</span></tt> if the key has no corresponding cache entry.</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">def</span> <span class=\"pre\">remove(key:</span> <span class=\"pre\">Any):</span> <span class=\"pre\">Option[Future[V]]</span></tt> removes the cache item for the given key.\nReturns the removed item if it was found (and removed).</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">def</span> <span class=\"pre\">clear()</span></tt> clears the cache by removing all entries.</li>\n</ul>\n<p>Note that the <tt class=\"docutils literal\"><span class=\"pre\">apply</span></tt> overloads require an implicit <tt class=\"docutils literal\"><span class=\"pre\">ExecutionContext</span></tt> to be in scope.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h2>Example</h2>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">scala.concurrent.Future</span>\n<span class=\"k\">import</span> <span class=\"nn\">akka.actor.ActorSystem</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.caching.</span><span class=\"o\">{</span><span class=\"nc\">LruCache</span><span class=\"o\">,</span> <span class=\"nc\">Cache</span><span class=\"o\">}</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.util._</span>\n\n<span class=\"k\">val</span> <span class=\"n\">system</span> <span class=\"k\">=</span> <span class=\"nc\">ActorSystem</span><span class=\"o\">()</span>\n<span class=\"k\">import</span> <span class=\"nn\">system.dispatcher</span>\n\n<span class=\"c1\">// if we have an &quot;expensive&quot; operation</span>\n<span class=\"k\">def</span> <span class=\"n\">expensiveOp</span><span class=\"o\">()</span><span class=\"k\">:</span> <span class=\"kt\">Double</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">util</span><span class=\"o\">.</span><span class=\"nc\">Random</span><span class=\"o\">().</span><span class=\"n\">nextDouble</span><span class=\"o\">()</span>\n\n<span class=\"c1\">// and a Cache for its result type</span>\n<span class=\"k\">val</span> <span class=\"n\">cache</span><span class=\"k\">:</span> <span class=\"kt\">Cache</span><span class=\"o\">[</span><span class=\"kt\">Double</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"nc\">LruCache</span><span class=\"o\">()</span>\n\n<span class=\"c1\">// we can wrap the operation with caching support</span>\n<span class=\"c1\">// (providing a caching key)</span>\n<span class=\"k\">def</span> <span class=\"n\">cachedOp</span><span class=\"o\">[</span><span class=\"kt\">T</span><span class=\"o\">](</span><span class=\"n\">key</span><span class=\"k\">:</span> <span class=\"kt\">T</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Future</span><span class=\"o\">[</span><span class=\"kt\">Double</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"n\">cache</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"n\">expensiveOp</span><span class=\"o\">()</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// and profit</span>\n<span class=\"n\">cachedOp</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span><span class=\"o\">).</span><span class=\"n\">await</span> <span class=\"o\">===</span> <span class=\"n\">cachedOp</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span><span class=\"o\">).</span><span class=\"n\">await</span>\n<span class=\"n\">cachedOp</span><span class=\"o\">(</span><span class=\"s\">&quot;bar&quot;</span><span class=\"o\">).</span><span class=\"n\">await</span> <span class=\"o\">!==</span> <span class=\"n\">cachedOp</span><span class=\"o\">(</span><span class=\"s\">&quot;foo&quot;</span><span class=\"o\">).</span><span class=\"n\">await</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"cache-implementations\">\n<h2>Cache Implementations</h2>\n<p><em>spray-caching</em> comes with two implementations of the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/master/spray-caching/src/main/scala/spray/caching/Cache.scala\">Cache</a> interface, <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/master/spray-caching/src/main/scala/spray/caching/LruCache.scala\">SimpleLruCache and ExpiringLruCache</a>,\nboth featuring last-recently-used cache eviction semantics and both internally wrapping a <a class=\"reference external\" href=\"http://code.google.com/p/concurrentlinkedhashmap/\">concurrentlinkedhashmap</a>.\nThey difference between the two only consists of whether they support time-based entry expiration or not.</p>\n<p>The easiest way to construct a cache instance is via the <tt class=\"docutils literal\"><span class=\"pre\">apply</span></tt> method of the <tt class=\"docutils literal\"><span class=\"pre\">LruCache</span></tt> object, which has the\nfollowing signature and creates a new <tt class=\"docutils literal\"><span class=\"pre\">ExpiringLruCache</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">SimpleLruCache</span></tt> depending on whether\n<tt class=\"docutils literal\"><span class=\"pre\">timeToLive</span></tt> and/or <tt class=\"docutils literal\"><span class=\"pre\">timeToIdle</span></tt> are finite (= expiring) or infinite:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"cm\">/**</span>\n<span class=\"cm\"> * Creates a new [[spray.caching.ExpiringLruCache]] or</span>\n<span class=\"cm\"> * [[spray.caching.SimpleLruCache]] instance depending on whether</span>\n<span class=\"cm\"> * a non-zero and finite timeToLive and/or timeToIdle is set or not.</span>\n<span class=\"cm\"> */</span>\n<span class=\"k\">def</span> <span class=\"n\">apply</span><span class=\"o\">[</span><span class=\"kt\">V</span><span class=\"o\">](</span><span class=\"n\">maxCapacity</span><span class=\"k\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span><span class=\"o\">,</span>\n             <span class=\"n\">initialCapacity</span><span class=\"k\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">=</span> <span class=\"mi\">16</span><span class=\"o\">,</span>\n             <span class=\"n\">timeToLive</span><span class=\"k\">:</span> <span class=\"kt\">Duration</span> <span class=\"o\">=</span> <span class=\"nc\">Duration</span><span class=\"o\">.</span><span class=\"nc\">Inf</span><span class=\"o\">,</span>\n             <span class=\"n\">timeToIdle</span><span class=\"k\">:</span> <span class=\"kt\">Duration</span> <span class=\"o\">=</span> <span class=\"nc\">Duration</span><span class=\"o\">.</span><span class=\"nc\">Inf</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Cache</span><span class=\"o\">[</span><span class=\"kt\">V</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"simplelrucache\">\n<h3>SimpleLruCache</h3>\n<p>This cache implementation has a defined maximum number of entries it can store. After the maximum capacity is reached\nnew entries cause old ones to be evicted in a last-recently-used manner, i.e. the entries that haven&#8217;t been accessed\nfor the longest time are evicted first.</p>\n</div>\n<div class=\"section\" id=\"expiringlrucache\">\n<h3>ExpiringLruCache</h3>\n<p>This implementation has the same limited capacity behavior as the <tt class=\"docutils literal\"><span class=\"pre\">SimpleLruCache</span></tt> but in addition supports\ntime-to-live as well as time-to-idle expiration.\nThe former provides an upper limit to the time period an entry is allowed to remain in the cache while the latter\nlimits the maximum time an entry is kept without having been accessed. If both values are finite the time-to-live\nhas to be strictly greater than the time-to-idle.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Expired entries are only evicted upon next access (or by being thrown out by the capacity constraint), so\nthey might prevent gargabe collection of their values for longer than expected.</p>\n</div>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "spray-caching", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-caching/index", "next": {"link": "../spray-can/", "title": "spray-can"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-can/index", "spray-can", "N", "next"], ["documentation/index", "Documentation", "P", "previous"]], "meta": {}, "parents": [{"link": "../", "title": "Documentation"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">spray-caching</a><ul>\n<li><a class=\"reference internal\" href=\"#dependencies\">Dependencies</a></li>\n<li><a class=\"reference internal\" href=\"#installation\">Installation</a></li>\n<li><a class=\"reference internal\" href=\"#the-cache-interface\">The <cite>Cache</cite> Interface</a></li>\n<li><a class=\"reference internal\" href=\"#example\">Example</a></li>\n<li><a class=\"reference internal\" href=\"#cache-implementations\">Cache Implementations</a><ul>\n<li><a class=\"reference internal\" href=\"#simplelrucache\">SimpleLruCache</a></li>\n<li><a class=\"reference internal\" href=\"#expiringlrucache\">ExpiringLruCache</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../", "title": "Documentation"}, "metatags": ""}